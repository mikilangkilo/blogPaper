---
title: jvm内存模型
date: 2019-01-02 23:48:21
tags: "jvm"
category: "java基础"
description: "本文是学习jvm内存模型相关"
---

![JVM内存模型示意图](/images/android/jvm内存模型.jpg)

## 内存计数器（PC寄存器）

由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，

因此，为了能够使得每个线程都在线程切换后能够恢复在切　换　之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，

否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，

因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。

内存计数器是context的一部分

## java 栈

Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、

指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、

方法返回地址(Return Address)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。　

```
经常有人把Java 内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗

糙，Java 内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序

员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”在后

面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变

量表部分。

局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、

float、long、double）、对象引用（reference 类型，它不等同于对象本身，根据不同的虚拟

机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或

者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。

其中64 位长度的long 和double 类型的数据会占用2 个局部变量空间（Slot），其余

的数据类型只占用1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个

方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间

不会改变局部变量表的大小。
```

## 本地方法栈

本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的

```
本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其

区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则

是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语

言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至

有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。

与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError

异常。

```

## java 堆

Java中的堆是用来存储对象本身的以及数组（数组引用是存放在Java栈中的）。堆是被所有线程共享的，在JVM中只有一个堆。

```
对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的

一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的

唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚

拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着JIT 编译器

的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙

的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。

Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（Garbage

Collected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在

收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；

再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配

的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local

Allocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，

存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配

内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java 堆中的上述各个区域的

分配和回收等细节将会是下一章的主题。

根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要

逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小

的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx

和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出

OutOfMemoryError 异常。
```

## 方法区

与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。

在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。

在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，

对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。

```
方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存

储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽

然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-

Heap（非堆），目的应该是与Java 堆区分开来。

对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区

称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚

拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而

已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。即

使是HotSpot 虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”

至Native Memory 来实现方法区的规划了。

Java 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内

存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾

收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一

样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸

载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件

相当苛刻，但是这部分区域的回收确实是有必要的。在Sun 公司的BUG 列表中，曾出

现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导

致内存泄漏。

根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出

OutOfMemoryError 异常。
```

## 静态区

静态区也称为运行常量池，static出来的对象都是静态的。该区域存放类和接口的常量，














